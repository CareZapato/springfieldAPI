import { Injectable, ɵɵdefineInjectable } from '@angular/core';
import { __awaiter, __generator, __assign, __spread } from 'tslib';
import fetchMock from 'fetch-mock/es5/client';
import xhrMock, { proxy } from 'xhr-mock';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/http-mocks.model.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function MockRequest() { }
if (false) {
    /** @type {?} */
    MockRequest.prototype.requestQuery;
    /** @type {?} */
    MockRequest.prototype.requestBody;
    /** @type {?} */
    MockRequest.prototype.requestHeaders;
}
/**
 * @record
 */
function MockResponse() { }
if (false) {
    /** @type {?} */
    MockResponse.prototype.responseBody;
    /** @type {?} */
    MockResponse.prototype.responseCode;
    /** @type {?} */
    MockResponse.prototype.responseHeaders;
}
/**
 * @record
 */
function Mock() { }
if (false) {
    /**
     * A regular expression that should match with the URL of the HTTP request.
     * @type {?}
     */
    Mock.prototype.url;
    /**
     * HTTP method.
     * @type {?}
     */
    Mock.prototype.method;
    /**
     * A function that contains a logic that returns response data accordingly to the request (query params and payload).
     * @type {?}
     */
    Mock.prototype.responseFn;
    /**
     * Status code of the HTTP transaction. (default: `200`)
     * @type {?|undefined}
     */
    Mock.prototype.responseCode;
    /**
     * Headers of the response. (default: `{}`)
     * @type {?|undefined}
     */
    Mock.prototype.responseHeaders;
    /**
     * Time of the response delay (in milliseconds). (default: `0`)
     * @type {?|undefined}
     */
    Mock.prototype.delay;
}
/**
 * @record
 */
function MockScenarios() { }
if (false) {
    /** @type {?} */
    MockScenarios.prototype.default;
    /* Skipping unhandled member: [mockScenario: string]: Mock[];*/
}
/**
 * @record
 */
function MockOptions() { }
if (false) {
    /**
     * Whether pass through the request to the network if no mock exists. (default: `true`)
     * @type {?|undefined}
     */
    MockOptions.prototype.fallbackToNetwork;
    /**
     * Whether log information about request/response of the mock to the console. (default: `false`)
     * @type {?|undefined}
     */
    MockOptions.prototype.loggingEnabled;
    /**
     * Whether accept search string placed after the hashtag in URL,
     * e.g. `http://localhost:4200/#/?mockScenario=scenarioKey`. (default: `false`)
     * @type {?|undefined}
     */
    MockOptions.prototype.useLocationHash;
    /**
     * The scenario key to use for mocking. (default: `'default'`)
     * @type {?|undefined}
     */
    MockOptions.prototype.mockScenario;
    /**
     * Common response code for all mocks that can be overridden by the response code of the particular mock. (default: `200`)
     * @type {?|undefined}
     */
    MockOptions.prototype.defaultResponseCode;
    /**
     * Common response headers for all mocks that can be overridden by the response headers of the particular mock. (default: `{}`)
     * @type {?|undefined}
     */
    MockOptions.prototype.defaultResponseHeaders;
    /**
     * Common mock delay for all mocks that can be overridden by the mock delay of the particular mock. (default: `0`)
     * @type {?|undefined}
     */
    MockOptions.prototype.defaultDelay;
    /**
     * Wrapper function that applies to all mock responses.
     * Useful when you change the overall data response structure without an impact on the data.
     * @type {?|undefined}
     */
    MockOptions.prototype.responseProxyFn;
    /**
     * Disables specific mocks.
     * With this option, you can easily disable particular mocks when you're about to connect to the real API.
     * @type {?|undefined}
     */
    MockOptions.prototype.ignoredMocks;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/query.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Extracts query string params and return them as an object.
 * \@param locationSearch Query string to process.
 * @type {?}
 */
var parseQueryParams = (/**
 * @param {?=} locationSearch
 * @return {?}
 */
function (locationSearch) {
    if (locationSearch === void 0) { locationSearch = ''; }
    /** @type {?} */
    var urlSearchParams = new URLSearchParams(locationSearch);
    /** @type {?} */
    var queryParams = {};
    urlSearchParams.forEach((/**
     * @param {?} value
     * @param {?} key
     * @return {?}
     */
    function (value, key) {
        queryParams[key] = value;
    }));
    return queryParams;
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/log.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Creates a collapsed group console log of the mock's request and response.
 * @type {?}
 */
var logMock = (/**
 * @param {?} __0
 * @param {?} __1
 * @param {?} __2
 * @return {?}
 */
function (_a, _b, _c) {
    var method = _a.method, url = _a.url, delay = _a.delay;
    var requestQuery = _b.requestQuery, requestBody = _b.requestBody, requestHeaders = _b.requestHeaders;
    var responseBody = _c.responseBody, responseCode = _c.responseCode, responseHeaders = _c.responseHeaders;
    console.groupCollapsed(method + " " + url);
    console.log('Status:', responseCode);
    console.log('Delay:', delay);
    console.group('Request');
    console.log('Headers:', requestHeaders);
    console.log('Query:', requestQuery);
    console.log('Body:', requestBody);
    console.groupEnd();
    console.group('Response');
    console.log('Headers:', responseHeaders);
    console.log('Body:', responseBody);
    console.groupEnd();
    console.groupEnd();
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/proxy.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var handleProxyFn = (/**
 * @param {?} responseBody
 * @param {?} mock
 * @param {?} mockRequest
 * @param {?=} proxyFn
 * @return {?}
 */
function (responseBody, mock, mockRequest, proxyFn) {
    return proxyFn && typeof proxyFn === 'function'
        ? proxyFn(responseBody, {
            url: mock.url,
            method: mock.method,
            responseCode: mock.responseCode,
            responseHeaders: mock.responseHeaders
        }, mockRequest)
        : {
            responseBody: responseBody,
            responseCode: mock.responseCode,
            responseHeaders: mock.responseHeaders
        };
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/fetch.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var fallbackToNetworkFetch = (/**
 * @param {?} fallbackToNetwork
 * @return {?}
 */
function (fallbackToNetwork) {
    fetchMock.config.fallbackToNetwork = fallbackToNetwork;
});
/** @type {?} */
var overwriteRoutesFetch = (/**
 * @param {?} overwriteRoutes
 * @return {?}
 */
function (overwriteRoutes) {
    fetchMock.config.overwriteRoutes = overwriteRoutes;
});
/** @type {?} */
var createFetchMock = (/**
 * @param {?} mock
 * @param {?} loggingEnabled
 * @param {?} responseProxyFn
 * @return {?}
 */
function (mock, loggingEnabled, responseProxyFn) {
    fetchMock.mock(mock.url, (/**
     * @param {?} url
     * @param {?} fetchMockOptions
     * @return {?}
     */
    function (url, fetchMockOptions) {
        var _a, _b;
        /** @type {?} */
        var body = ((_a = fetchMockOptions) === null || _a === void 0 ? void 0 : _a.body) || {};
        /** @type {?} */
        var headers = ((_b = fetchMockOptions) === null || _b === void 0 ? void 0 : _b.headers) || {};
        /** @type {?} */
        var createdURL = createURL(url);
        // request
        /** @type {?} */
        var requestQuery = parseQueryParams(createdURL !== null
            ? createdURL.search
            : removeAllBeforeChar(url.toString(), '?'));
        /** @type {?} */
        var requestBody = typeof body === 'string' ? JSON.parse(body) : body;
        /** @type {?} */
        var requestHeaders = headers;
        // response
        /** @type {?} */
        var responseBody = mock.responseFn(requestQuery, requestBody);
        /** @type {?} */
        var responseData = handleProxyFn(responseBody, mock, {
            requestQuery: requestQuery,
            requestBody: requestBody,
            requestHeaders: requestHeaders
        }, responseProxyFn);
        /** @type {?} */
        var response = {
            headers: responseData.responseHeaders,
            status: responseData.responseCode,
            body: responseData.responseBody
        };
        if (loggingEnabled) {
            logMock(mock, {
                requestQuery: requestQuery,
                requestBody: requestBody,
                requestHeaders: requestHeaders
            }, responseData);
        }
        return response;
    }), {
        delay: mock.delay
    });
});
/**
 * Tries to create a new instace of URL()
 * @type {?}
 */
var createURL = (/**
 * @param {?} url
 * @return {?}
 */
function (url) {
    try {
        return new URL("" + url);
    }
    catch (_) {
        return null;
    }
});
var ɵ0 = createURL;
/**
 * Removes all chars before specific char (char includes).
 * If char doesn't exist, returns an empty string.
 * @type {?}
 */
var removeAllBeforeChar = (/**
 * @param {?} value
 * @param {?} char
 * @return {?}
 */
function (value, char) {
    if (!value.includes(char)) {
        return '';
    }
    return ("" + value).split(char).pop();
});
var ɵ1 = removeAllBeforeChar;

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/delay.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// SOURCE: https://github.com/sindresorhus/delay
/**
 * @record
 */
function AbortSignal() { }
if (false) {
    /** @type {?} */
    AbortSignal.prototype.aborted;
    /**
     * @param {?} type
     * @param {?} listener
     * @param {?=} options
     * @return {?}
     */
    AbortSignal.prototype.addEventListener = function (type, listener, options) { };
    /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    AbortSignal.prototype.removeEventListener = function (type, listener) { };
}
/**
 * @record
 */
function Options() { }
if (false) {
    /** @type {?|undefined} */
    Options.prototype.signal;
}
/**
 * @record
 * @template T
 */
function ClearablePromise() { }
if (false) {
    /**
     * @return {?}
     */
    ClearablePromise.prototype.clear = function () { };
}
/**
 * @record
 */
function Delay() { }
if (false) {
    /** @type {?|undefined} */
    Delay.prototype.reject;
    /** @type {?|undefined} */
    Delay.prototype.createWithTimers;
    /* Skipping unhandled member: (milliseconds: number, options?: Options): ClearablePromise<void>;*/
    /* Skipping unhandled member: <T>(
        milliseconds: number,
        options?: Options & {
          value: T;
        }
      ): ClearablePromise<T>;*/
}
/** @type {?} */
var createAbortError = (/**
 * @return {?}
 */
function () {
    /** @type {?} */
    var error = new Error('Delay aborted');
    error.name = 'AbortError';
    return error;
});
var ɵ0$1 = createAbortError;
/** @type {?} */
var createDelay = (/**
 * @param {?} __0
 * @return {?}
 */
function (_a) {
    var defaultClear = _a.clearTimeout, set = _a.setTimeout, willResolve = _a.willResolve;
    return (/**
     * @param {?} ms
     * @param {?=} __1
     * @return {?}
     */
    function (ms, _a) {
        var _b = _a === void 0 ? (/** @type {?} */ ({})) : _a, value = _b.value, signal = _b.signal;
        if (signal && signal.aborted) {
            return Promise.reject(createAbortError());
        }
        /** @type {?} */
        var timeoutId;
        /** @type {?} */
        var settle;
        /** @type {?} */
        var rejectFn;
        /** @type {?} */
        var clear = defaultClear || clearTimeout;
        /** @type {?} */
        var signalListener = (/**
         * @return {?}
         */
        function () {
            clear(timeoutId);
            rejectFn(createAbortError());
        });
        /** @type {?} */
        var cleanup = (/**
         * @return {?}
         */
        function () {
            if (signal) {
                signal.removeEventListener('abort', signalListener);
            }
        });
        /** @type {?} */
        var delayPromise = new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        function (resolve, reject) {
            settle = (/**
             * @return {?}
             */
            function () {
                cleanup();
                if (willResolve) {
                    resolve(value);
                }
                else {
                    reject(value);
                }
            });
            rejectFn = reject;
            timeoutId = (set || setTimeout)(settle, ms);
        }));
        if (signal) {
            signal.addEventListener('abort', signalListener, { once: true });
        }
        delayPromise.clear = (/**
         * @return {?}
         */
        function () {
            clear(timeoutId);
            timeoutId = null;
            settle();
        });
        return delayPromise;
    });
});
/** @type {?} */
var delay = createDelay({ willResolve: true });
delay.reject = createDelay({ willResolve: false });
delay.createWithTimers = (/**
 * @param {?} __0
 * @return {?}
 */
function (_a) {
    var clearTimeout = _a.clearTimeout, setTimeout = _a.setTimeout;
    /** @type {?} */
    var innerDelay = createDelay({
        clearTimeout: clearTimeout,
        setTimeout: setTimeout,
        willResolve: true
    });
    innerDelay.reject = createDelay({
        clearTimeout: clearTimeout,
        setTimeout: setTimeout,
        willResolve: false
    });
    return innerDelay;
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/xhr.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var setupXHRMock = (/**
 * @return {?}
 */
function () {
    xhrMock.setup();
});
/** @type {?} */
var fallbackToNetworkXHR = (/**
 * @param {?} fallbackToNetwork
 * @return {?}
 */
function (fallbackToNetwork) {
    if (fallbackToNetwork) {
        xhrMock.use(proxy);
    }
});
/** @type {?} */
var createXHRMock = (/**
 * @param {?} mock
 * @param {?} loggingEnabled
 * @param {?=} responseProxyFn
 * @return {?}
 */
function (mock, loggingEnabled, responseProxyFn) {
    xhrMock.use(mock.method, mock.url, (/**
     * @param {?} mockRequest
     * @param {?} mockResponse
     * @return {?}
     */
    function (mockRequest, mockResponse) { return __awaiter(void 0, void 0, void 0, function () {
        var requestQuery, requestBody, requestHeaders, responseBody, responseData, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    // request
                    requestQuery = mockRequest.url().query || {};
                    requestBody = mockRequest.body() != null ? JSON.parse(mockRequest.body()) : {};
                    requestHeaders = mockRequest.headers();
                    // response
                    responseBody = mock.responseFn(requestQuery, requestBody);
                    responseData = handleProxyFn(responseBody, mock, {
                        requestQuery: requestQuery,
                        requestBody: requestBody,
                        requestHeaders: requestHeaders
                    }, responseProxyFn);
                    response = mockResponse
                        .status(responseData.responseCode)
                        .body(responseData.responseBody)
                        .headers(responseData.responseHeaders);
                    return [4 /*yield*/, delay(mock.delay)];
                case 1:
                    _a.sent();
                    if (loggingEnabled) {
                        logMock(mock, {
                            requestQuery: requestQuery,
                            requestBody: requestBody,
                            requestHeaders: requestHeaders
                        }, responseData);
                    }
                    return [2 /*return*/, response];
            }
        });
    }); }));
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/inject-http-mocks.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Main `http-mocks` method that handles entire creation of mocks for XHR and Fetch API.
 * @type {?}
 */
var injectHttpMocks = (/**
 * @param {?} mockScenarios
 * @param {?=} __1
 * @return {?}
 */
function (mockScenarios, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.fallbackToNetwork, fallbackToNetwork = _c === void 0 ? true : _c, _d = _b.loggingEnabled, loggingEnabled = _d === void 0 ? false : _d, _e = _b.useLocationHash, useLocationHash = _e === void 0 ? false : _e, _f = _b.mockScenario, mockScenario = _f === void 0 ? extractMockScenarioFromLocation(window.location, useLocationHash) : _f, _g = _b.defaultResponseCode, defaultResponseCode = _g === void 0 ? 200 : _g, _h = _b.defaultResponseHeaders, defaultResponseHeaders = _h === void 0 ? {} : _h, _j = _b.defaultDelay, defaultDelay = _j === void 0 ? 0 : _j, responseProxyFn = _b.responseProxyFn, _k = _b.ignoredMocks, ignoredMocks = _k === void 0 ? [] : _k;
    // this needs to be placed before creating the XHR mocks
    setupXHRMock();
    // convert ignored mocks RegExps to the strings
    /** @type {?} */
    var ignoredMocksStrings = Array.isArray(ignoredMocks) && ignoredMocks.length
        ? ignoredMocks.map((/**
         * @param {?} value
         * @return {?}
         */
        function (value) { return value.toString(); }))
        : [];
    // pick the right scenario mocks and create mock for every mock definition
    getScenarioMocks(mockScenarios, mockScenario)
        .filter((/**
     * @param {?} mock
     * @return {?}
     */
    function (mock) { return !ignoredMocksStrings.includes(mock.url.toString()); }))
        .forEach((/**
     * @param {?} mock
     * @return {?}
     */
    function (mock) {
        // use default values in the first place
        /** @type {?} */
        var updatedMock = __assign({ responseCode: defaultResponseCode, responseHeaders: defaultResponseHeaders, delay: defaultDelay }, mock);
        // create mocks for both XHR an Fetch API
        createXHRMock(updatedMock, loggingEnabled, responseProxyFn);
        createFetchMock(updatedMock, loggingEnabled, responseProxyFn);
    }));
    // turn `fallbackToNetwork` on/off
    fallbackToNetworkXHR(fallbackToNetwork);
    fallbackToNetworkFetch(fallbackToNetwork);
    // turn `overwriteRoutesFetch` on/off (Fetch API only)
    overwriteRoutesFetch(true);
});
/**
 * Gets the corresponding value for `mockScenario` key in the browser's Location object.
 * \@param location The location object (accesible via `window.location`)
 * \@param useLocationHash Whether during a search for search params in URL accept hashtag or not.
 * @type {?}
 */
var extractMockScenarioFromLocation = (/**
 * @param {?} location
 * @param {?} useLocationHash
 * @return {?}
 */
function (location, useLocationHash) {
    /** @type {?} */
    var locationSearch = useLocationHash
        ? // remove leading symbols like: `#`, `#/`, `/`
            location.hash.replace(/^(#\/|#|\/)+/g, '')
        : location.search;
    var _a = parseQueryParams(locationSearch).mockScenario, mockScenario = _a === void 0 ? 'default' : _a;
    if (Array.isArray(mockScenario)) {
        throw new Error('Error during processing the mock scenario');
    }
    return mockScenario;
});
/**
 * Picks the mocks from the current mock scenario.
 * \@param mockScenarios Map of the mock scenarios.
 * \@param mockScenario Key of the current mock scenario.
 * @type {?}
 */
var getScenarioMocks = (/**
 * @param {?} mockScenarios
 * @param {?} mockScenario
 * @return {?}
 */
function (mockScenarios, mockScenario) {
    /** @type {?} */
    var defaultMocks = mockScenarios.default;
    if (mockScenario === 'default') {
        return defaultMocks;
    }
    /** @type {?} */
    var selectedMocks = mockScenarios[mockScenario];
    if (!selectedMocks) {
        throw new Error("No mocks found for mock scenario: '" + mockScenario + "'");
    }
    return __spread(selectedMocks, defaultMocks.filter((/**
     * @param {?} defaultMock
     * @return {?}
     */
    function (defaultMock) {
        return selectedMocks.findIndex((/**
         * @param {?} mock
         * @return {?}
         */
        function (mock) {
            return mock.method === defaultMock.method &&
                mock.url.toString() === defaultMock.url.toString();
        })) === -1;
    })));
});
var ɵ0$2 = getScenarioMocks;

/**
 * @fileoverview added by tsickle
 * Generated from: lib/http-mocks.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var HttpMocksService = /** @class */ (function () {
    function HttpMocksService() {
    }
    /**
     * @param {?} mockScenarios
     * @param {?} mockOptions
     * @return {?}
     */
    HttpMocksService.prototype.setHttpMocks = /**
     * @param {?} mockScenarios
     * @param {?} mockOptions
     * @return {?}
     */
    function (mockScenarios, mockOptions) {
        injectHttpMocks(mockScenarios, mockOptions);
    };
    HttpMocksService.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */ HttpMocksService.ɵprov = ɵɵdefineInjectable({ factory: function HttpMocksService_Factory() { return new HttpMocksService(); }, token: HttpMocksService, providedIn: "root" });
    return HttpMocksService;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: http-mocks.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { HttpMocksService, injectHttpMocks };
//# sourceMappingURL=http-mocks.js.map
