import { Injectable, ɵɵdefineInjectable } from '@angular/core';
import fetchMock from 'fetch-mock/es5/client';
import { __awaiter } from 'tslib';
import xhrMock, { proxy } from 'xhr-mock';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/http-mocks.model.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function MockRequest() { }
if (false) {
    /** @type {?} */
    MockRequest.prototype.requestQuery;
    /** @type {?} */
    MockRequest.prototype.requestBody;
    /** @type {?} */
    MockRequest.prototype.requestHeaders;
}
/**
 * @record
 */
function MockResponse() { }
if (false) {
    /** @type {?} */
    MockResponse.prototype.responseBody;
    /** @type {?} */
    MockResponse.prototype.responseCode;
    /** @type {?} */
    MockResponse.prototype.responseHeaders;
}
/**
 * @record
 */
function Mock() { }
if (false) {
    /**
     * A regular expression that should match with the URL of the HTTP request.
     * @type {?}
     */
    Mock.prototype.url;
    /**
     * HTTP method.
     * @type {?}
     */
    Mock.prototype.method;
    /**
     * A function that contains a logic that returns response data accordingly to the request (query params and payload).
     * @type {?}
     */
    Mock.prototype.responseFn;
    /**
     * Status code of the HTTP transaction. (default: `200`)
     * @type {?|undefined}
     */
    Mock.prototype.responseCode;
    /**
     * Headers of the response. (default: `{}`)
     * @type {?|undefined}
     */
    Mock.prototype.responseHeaders;
    /**
     * Time of the response delay (in milliseconds). (default: `0`)
     * @type {?|undefined}
     */
    Mock.prototype.delay;
}
/**
 * @record
 */
function MockScenarios() { }
if (false) {
    /** @type {?} */
    MockScenarios.prototype.default;
    /* Skipping unhandled member: [mockScenario: string]: Mock[];*/
}
/**
 * @record
 */
function MockOptions() { }
if (false) {
    /**
     * Whether pass through the request to the network if no mock exists. (default: `true`)
     * @type {?|undefined}
     */
    MockOptions.prototype.fallbackToNetwork;
    /**
     * Whether log information about request/response of the mock to the console. (default: `false`)
     * @type {?|undefined}
     */
    MockOptions.prototype.loggingEnabled;
    /**
     * Whether accept search string placed after the hashtag in URL,
     * e.g. `http://localhost:4200/#/?mockScenario=scenarioKey`. (default: `false`)
     * @type {?|undefined}
     */
    MockOptions.prototype.useLocationHash;
    /**
     * The scenario key to use for mocking. (default: `'default'`)
     * @type {?|undefined}
     */
    MockOptions.prototype.mockScenario;
    /**
     * Common response code for all mocks that can be overridden by the response code of the particular mock. (default: `200`)
     * @type {?|undefined}
     */
    MockOptions.prototype.defaultResponseCode;
    /**
     * Common response headers for all mocks that can be overridden by the response headers of the particular mock. (default: `{}`)
     * @type {?|undefined}
     */
    MockOptions.prototype.defaultResponseHeaders;
    /**
     * Common mock delay for all mocks that can be overridden by the mock delay of the particular mock. (default: `0`)
     * @type {?|undefined}
     */
    MockOptions.prototype.defaultDelay;
    /**
     * Wrapper function that applies to all mock responses.
     * Useful when you change the overall data response structure without an impact on the data.
     * @type {?|undefined}
     */
    MockOptions.prototype.responseProxyFn;
    /**
     * Disables specific mocks.
     * With this option, you can easily disable particular mocks when you're about to connect to the real API.
     * @type {?|undefined}
     */
    MockOptions.prototype.ignoredMocks;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/query.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Extracts query string params and return them as an object.
 * \@param locationSearch Query string to process.
 * @type {?}
 */
const parseQueryParams = (/**
 * @param {?=} locationSearch
 * @return {?}
 */
(locationSearch = '') => {
    /** @type {?} */
    const urlSearchParams = new URLSearchParams(locationSearch);
    /** @type {?} */
    const queryParams = {};
    urlSearchParams.forEach((/**
     * @param {?} value
     * @param {?} key
     * @return {?}
     */
    (value, key) => {
        queryParams[key] = value;
    }));
    return queryParams;
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/log.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Creates a collapsed group console log of the mock's request and response.
 * @type {?}
 */
const logMock = (/**
 * @param {?} __0
 * @param {?} __1
 * @param {?} __2
 * @return {?}
 */
({ method, url, delay }, { requestQuery, requestBody, requestHeaders }, { responseBody, responseCode, responseHeaders }) => {
    console.groupCollapsed(`${method} ${url}`);
    console.log('Status:', responseCode);
    console.log('Delay:', delay);
    console.group('Request');
    console.log('Headers:', requestHeaders);
    console.log('Query:', requestQuery);
    console.log('Body:', requestBody);
    console.groupEnd();
    console.group('Response');
    console.log('Headers:', responseHeaders);
    console.log('Body:', responseBody);
    console.groupEnd();
    console.groupEnd();
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/proxy.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const handleProxyFn = (/**
 * @param {?} responseBody
 * @param {?} mock
 * @param {?} mockRequest
 * @param {?=} proxyFn
 * @return {?}
 */
(responseBody, mock, mockRequest, proxyFn) => {
    return proxyFn && typeof proxyFn === 'function'
        ? proxyFn(responseBody, {
            url: mock.url,
            method: mock.method,
            responseCode: mock.responseCode,
            responseHeaders: mock.responseHeaders
        }, mockRequest)
        : {
            responseBody,
            responseCode: mock.responseCode,
            responseHeaders: mock.responseHeaders
        };
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/fetch.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const fallbackToNetworkFetch = (/**
 * @param {?} fallbackToNetwork
 * @return {?}
 */
(fallbackToNetwork) => {
    fetchMock.config.fallbackToNetwork = fallbackToNetwork;
});
/** @type {?} */
const overwriteRoutesFetch = (/**
 * @param {?} overwriteRoutes
 * @return {?}
 */
(overwriteRoutes) => {
    fetchMock.config.overwriteRoutes = overwriteRoutes;
});
/** @type {?} */
const createFetchMock = (/**
 * @param {?} mock
 * @param {?} loggingEnabled
 * @param {?} responseProxyFn
 * @return {?}
 */
(mock, loggingEnabled, responseProxyFn) => {
    fetchMock.mock(mock.url, (/**
     * @param {?} url
     * @param {?} fetchMockOptions
     * @return {?}
     */
    (url, fetchMockOptions) => {
        var _a, _b;
        /** @type {?} */
        const body = ((_a = fetchMockOptions) === null || _a === void 0 ? void 0 : _a.body) || {};
        /** @type {?} */
        const headers = ((_b = fetchMockOptions) === null || _b === void 0 ? void 0 : _b.headers) || {};
        /** @type {?} */
        const createdURL = createURL(url);
        // request
        /** @type {?} */
        const requestQuery = parseQueryParams(createdURL !== null
            ? createdURL.search
            : removeAllBeforeChar(url.toString(), '?'));
        /** @type {?} */
        const requestBody = typeof body === 'string' ? JSON.parse(body) : body;
        /** @type {?} */
        const requestHeaders = headers;
        // response
        /** @type {?} */
        const responseBody = mock.responseFn(requestQuery, requestBody);
        /** @type {?} */
        const responseData = handleProxyFn(responseBody, mock, {
            requestQuery,
            requestBody,
            requestHeaders
        }, responseProxyFn);
        /** @type {?} */
        const response = {
            headers: responseData.responseHeaders,
            status: responseData.responseCode,
            body: responseData.responseBody
        };
        if (loggingEnabled) {
            logMock(mock, {
                requestQuery,
                requestBody,
                requestHeaders
            }, responseData);
        }
        return response;
    }), {
        delay: mock.delay
    });
});
/**
 * Tries to create a new instace of URL()
 * @type {?}
 */
const createURL = (/**
 * @param {?} url
 * @return {?}
 */
(url) => {
    try {
        return new URL(`${url}`);
    }
    catch (_) {
        return null;
    }
});
const ɵ0 = createURL;
/**
 * Removes all chars before specific char (char includes).
 * If char doesn't exist, returns an empty string.
 * @type {?}
 */
const removeAllBeforeChar = (/**
 * @param {?} value
 * @param {?} char
 * @return {?}
 */
(value, char) => {
    if (!value.includes(char)) {
        return '';
    }
    return `${value}`.split(char).pop();
});
const ɵ1 = removeAllBeforeChar;

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/delay.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// SOURCE: https://github.com/sindresorhus/delay
/**
 * @record
 */
function AbortSignal() { }
if (false) {
    /** @type {?} */
    AbortSignal.prototype.aborted;
    /**
     * @param {?} type
     * @param {?} listener
     * @param {?=} options
     * @return {?}
     */
    AbortSignal.prototype.addEventListener = function (type, listener, options) { };
    /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    AbortSignal.prototype.removeEventListener = function (type, listener) { };
}
/**
 * @record
 */
function Options() { }
if (false) {
    /** @type {?|undefined} */
    Options.prototype.signal;
}
/**
 * @record
 * @template T
 */
function ClearablePromise() { }
if (false) {
    /**
     * @return {?}
     */
    ClearablePromise.prototype.clear = function () { };
}
/**
 * @record
 */
function Delay() { }
if (false) {
    /** @type {?|undefined} */
    Delay.prototype.reject;
    /** @type {?|undefined} */
    Delay.prototype.createWithTimers;
    /* Skipping unhandled member: (milliseconds: number, options?: Options): ClearablePromise<void>;*/
    /* Skipping unhandled member: <T>(
        milliseconds: number,
        options?: Options & {
          value: T;
        }
      ): ClearablePromise<T>;*/
}
/** @type {?} */
const createAbortError = (/**
 * @return {?}
 */
() => {
    /** @type {?} */
    const error = new Error('Delay aborted');
    error.name = 'AbortError';
    return error;
});
const ɵ0$1 = createAbortError;
/** @type {?} */
const createDelay = (/**
 * @param {?} __0
 * @return {?}
 */
({ clearTimeout: defaultClear, setTimeout: set, willResolve }) => (/**
 * @param {?} ms
 * @param {?=} __1
 * @return {?}
 */
(ms, { value, signal } = (/** @type {?} */ ({}))) => {
    if (signal && signal.aborted) {
        return Promise.reject(createAbortError());
    }
    /** @type {?} */
    let timeoutId;
    /** @type {?} */
    let settle;
    /** @type {?} */
    let rejectFn;
    /** @type {?} */
    const clear = defaultClear || clearTimeout;
    /** @type {?} */
    const signalListener = (/**
     * @return {?}
     */
    () => {
        clear(timeoutId);
        rejectFn(createAbortError());
    });
    /** @type {?} */
    const cleanup = (/**
     * @return {?}
     */
    () => {
        if (signal) {
            signal.removeEventListener('abort', signalListener);
        }
    });
    /** @type {?} */
    const delayPromise = new Promise((/**
     * @param {?} resolve
     * @param {?} reject
     * @return {?}
     */
    (resolve, reject) => {
        settle = (/**
         * @return {?}
         */
        () => {
            cleanup();
            if (willResolve) {
                resolve(value);
            }
            else {
                reject(value);
            }
        });
        rejectFn = reject;
        timeoutId = (set || setTimeout)(settle, ms);
    }));
    if (signal) {
        signal.addEventListener('abort', signalListener, { once: true });
    }
    delayPromise.clear = (/**
     * @return {?}
     */
    () => {
        clear(timeoutId);
        timeoutId = null;
        settle();
    });
    return delayPromise;
}));
/** @type {?} */
const delay = createDelay({ willResolve: true });
delay.reject = createDelay({ willResolve: false });
delay.createWithTimers = (/**
 * @param {?} __0
 * @return {?}
 */
({ clearTimeout, setTimeout }) => {
    /** @type {?} */
    const innerDelay = createDelay({
        clearTimeout,
        setTimeout,
        willResolve: true
    });
    innerDelay.reject = createDelay({
        clearTimeout,
        setTimeout,
        willResolve: false
    });
    return innerDelay;
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/xhr.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const setupXHRMock = (/**
 * @return {?}
 */
() => {
    xhrMock.setup();
});
/** @type {?} */
const fallbackToNetworkXHR = (/**
 * @param {?} fallbackToNetwork
 * @return {?}
 */
(fallbackToNetwork) => {
    if (fallbackToNetwork) {
        xhrMock.use(proxy);
    }
});
/** @type {?} */
const createXHRMock = (/**
 * @param {?} mock
 * @param {?} loggingEnabled
 * @param {?=} responseProxyFn
 * @return {?}
 */
(mock, loggingEnabled, responseProxyFn) => {
    xhrMock.use(mock.method, mock.url, (/**
     * @param {?} mockRequest
     * @param {?} mockResponse
     * @return {?}
     */
    (mockRequest, mockResponse) => __awaiter(void 0, void 0, void 0, function* () {
        // request
        /** @type {?} */
        const requestQuery = mockRequest.url().query || {};
        /** @type {?} */
        const requestBody = mockRequest.body() != null ? JSON.parse(mockRequest.body()) : {};
        /** @type {?} */
        const requestHeaders = mockRequest.headers();
        // response
        /** @type {?} */
        const responseBody = mock.responseFn(requestQuery, requestBody);
        /** @type {?} */
        const responseData = handleProxyFn(responseBody, mock, {
            requestQuery,
            requestBody,
            requestHeaders
        }, responseProxyFn);
        /** @type {?} */
        const response = mockResponse
            .status(responseData.responseCode)
            .body(responseData.responseBody)
            .headers(responseData.responseHeaders);
        yield delay(mock.delay);
        if (loggingEnabled) {
            logMock(mock, {
                requestQuery,
                requestBody,
                requestHeaders
            }, responseData);
        }
        return response;
    })));
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/inject-http-mocks.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Main `http-mocks` method that handles entire creation of mocks for XHR and Fetch API.
 * @type {?}
 */
const injectHttpMocks = (/**
 * @param {?} mockScenarios
 * @param {?=} __1
 * @return {?}
 */
(mockScenarios, { fallbackToNetwork = true, loggingEnabled = false, useLocationHash = false, mockScenario = extractMockScenarioFromLocation(window.location, useLocationHash), defaultResponseCode = 200, defaultResponseHeaders = {}, defaultDelay = 0, responseProxyFn, ignoredMocks = [] } = {}) => {
    // this needs to be placed before creating the XHR mocks
    setupXHRMock();
    // convert ignored mocks RegExps to the strings
    /** @type {?} */
    const ignoredMocksStrings = Array.isArray(ignoredMocks) && ignoredMocks.length
        ? ignoredMocks.map((/**
         * @param {?} value
         * @return {?}
         */
        (value) => value.toString()))
        : [];
    // pick the right scenario mocks and create mock for every mock definition
    getScenarioMocks(mockScenarios, mockScenario)
        .filter((/**
     * @param {?} mock
     * @return {?}
     */
    (mock) => !ignoredMocksStrings.includes(mock.url.toString())))
        .forEach((/**
     * @param {?} mock
     * @return {?}
     */
    (mock) => {
        // use default values in the first place
        /** @type {?} */
        const updatedMock = Object.assign({ responseCode: defaultResponseCode, responseHeaders: defaultResponseHeaders, delay: defaultDelay }, mock);
        // create mocks for both XHR an Fetch API
        createXHRMock(updatedMock, loggingEnabled, responseProxyFn);
        createFetchMock(updatedMock, loggingEnabled, responseProxyFn);
    }));
    // turn `fallbackToNetwork` on/off
    fallbackToNetworkXHR(fallbackToNetwork);
    fallbackToNetworkFetch(fallbackToNetwork);
    // turn `overwriteRoutesFetch` on/off (Fetch API only)
    overwriteRoutesFetch(true);
});
/**
 * Gets the corresponding value for `mockScenario` key in the browser's Location object.
 * \@param location The location object (accesible via `window.location`)
 * \@param useLocationHash Whether during a search for search params in URL accept hashtag or not.
 * @type {?}
 */
const extractMockScenarioFromLocation = (/**
 * @param {?} location
 * @param {?} useLocationHash
 * @return {?}
 */
(location, useLocationHash) => {
    /** @type {?} */
    const locationSearch = useLocationHash
        ? // remove leading symbols like: `#`, `#/`, `/`
            location.hash.replace(/^(#\/|#|\/)+/g, '')
        : location.search;
    const { mockScenario = 'default' } = parseQueryParams(locationSearch);
    if (Array.isArray(mockScenario)) {
        throw new Error('Error during processing the mock scenario');
    }
    return mockScenario;
});
/**
 * Picks the mocks from the current mock scenario.
 * \@param mockScenarios Map of the mock scenarios.
 * \@param mockScenario Key of the current mock scenario.
 * @type {?}
 */
const getScenarioMocks = (/**
 * @param {?} mockScenarios
 * @param {?} mockScenario
 * @return {?}
 */
(mockScenarios, mockScenario) => {
    /** @type {?} */
    const defaultMocks = mockScenarios.default;
    if (mockScenario === 'default') {
        return defaultMocks;
    }
    /** @type {?} */
    const selectedMocks = mockScenarios[mockScenario];
    if (!selectedMocks) {
        throw new Error(`No mocks found for mock scenario: '${mockScenario}'`);
    }
    return [
        ...selectedMocks,
        ...defaultMocks.filter((/**
         * @param {?} defaultMock
         * @return {?}
         */
        (defaultMock) => selectedMocks.findIndex((/**
         * @param {?} mock
         * @return {?}
         */
        (mock) => mock.method === defaultMock.method &&
            mock.url.toString() === defaultMock.url.toString())) === -1))
    ];
});
const ɵ0$2 = getScenarioMocks;

/**
 * @fileoverview added by tsickle
 * Generated from: lib/http-mocks.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpMocksService {
    /**
     * @param {?} mockScenarios
     * @param {?} mockOptions
     * @return {?}
     */
    setHttpMocks(mockScenarios, mockOptions) {
        injectHttpMocks(mockScenarios, mockOptions);
    }
}
HttpMocksService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ HttpMocksService.ɵprov = ɵɵdefineInjectable({ factory: function HttpMocksService_Factory() { return new HttpMocksService(); }, token: HttpMocksService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: http-mocks.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { HttpMocksService, injectHttpMocks };
//# sourceMappingURL=http-mocks.js.map
